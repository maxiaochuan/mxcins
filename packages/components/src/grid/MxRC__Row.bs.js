// Generated by ReScript, PLEASE EDIT WITH CARE

import * as React from "react";
import * as Twind from "twind";
import * as Css from "twind/css";
import * as MxRC__Grid from "./MxRC__Grid.bs.js";
import * as Belt_Option from "rescript/lib/es6/belt_Option.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as MxRC__Libs__Utils from "../_libs/MxRC__Libs__Utils.bs.js";

function make(gap) {
  return {
          gap: gap
        };
}

var init = {
  gap: MxRC__Libs__Utils.BreakpointUtils.makeBreakpointNumberHashArray(undefined)
};

var context = React.createContext(init);

var provider = context.Provider;

function MxRC__Row$RowContext$Provider(Props) {
  var value = Props.value;
  var children = Props.children;
  return React.createElement(provider, {
              value: value,
              children: children
            });
}

var Provider = {
  provider: provider,
  make: MxRC__Row$RowContext$Provider
};

var RowContext = {
  make: make,
  init: init,
  context: context,
  Provider: Provider
};

var init$1 = "flex";

function make$1(className, wrap, justify, align, gap) {
  console.log("classes make", wrap, justify, gap);
  var classes = [init$1];
  classes.push(wrap ? "flex-wrap" : "flex-nowrap");
  classes.push(justify === "space-between" ? "justify-space-between" : (
          justify === "end" ? "justify-end" : (
              justify === "start" ? "justify-start" : (
                  justify === "center" ? "justify-center" : "justify-space-around"
                )
            )
        ));
  classes.push(align === "start" ? "items-start" : (
          align === "center" ? "items-center" : "items-end"
        ));
  var n2 = gap[1];
  var n1 = gap[0];
  if (n1 !== 0) {
    var str = Css.css({
          "column-gap": n1.toString() + "px;"
        });
    classes.push(str);
  }
  if (n2 !== 0) {
    var str$1 = Css.css({
          "row-gap": n2.toString() + "px;"
        });
    classes.push(str$1);
  }
  var match = Twind.tw(Twind.apply(classes));
  if (className !== undefined) {
    return [
              match,
              className
            ].join(" ");
  } else {
    return match;
  }
}

var GridRowTwind = {
  init: init$1,
  make: make$1
};

function MxRC__Row(Props) {
  var className = Props.className;
  var style = Props.style;
  var wrapOpt = Props.wrap;
  var justifyOpt = Props.justify;
  var alignOpt = Props.align;
  var gap = Props.gap;
  var children = Props.children;
  var wrap = wrapOpt !== undefined ? wrapOpt : true;
  var justify = justifyOpt !== undefined ? justifyOpt : "start";
  var align = alignOpt !== undefined ? alignOpt : "start";
  var gap$1 = MxRC__Libs__Utils.BreakpointUtils.makeBreakpointNumberHashArray(gap);
  var screens = MxRC__Grid.useBreakpoint(undefined);
  var gap$2 = MxRC__Libs__Utils.BreakpointUtils.getCurrentBreakpointValue(gap$1, screens);
  var className$1 = make$1(className, wrap, justify, align, gap$2);
  var children$1 = Belt_Option.getWithDefault(children, null);
  var tmp = {
    className: className$1
  };
  if (style !== undefined) {
    tmp.style = Caml_option.valFromOption(style);
  }
  return React.createElement("div", tmp, children$1);
}

var make$2 = MxRC__Row;

export {
  RowContext ,
  GridRowTwind ,
  make$2 as make,
  
}
/* init Not a pure module */
