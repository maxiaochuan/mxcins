// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Curry from "rescript/lib/es6/curry.js";
import * as React from "react";
import * as Twind from "twind";
import * as Belt_Map from "rescript/lib/es6/belt_Map.js";
import * as Belt_Option from "rescript/lib/es6/belt_Option.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as MxLibs__BreakpointSub from "@mxcins/webapi/src/breakpoint-sub/MxLibs__BreakpointSub.bs.js";

var ctx = React.createContext({
      spacex: 0
    });

function make(spacex) {
  return {
          spacex: spacex
        };
}

var provider = ctx.Provider;

function MxRC__Grid__Row$GridRowContext$Provider(Props) {
  var value = Props.value;
  var children = Props.children;
  return React.createElement(provider, {
              value: value,
              children: children
            });
}

var Provider = {
  provider: provider,
  make: MxRC__Grid__Row$GridRowContext$Provider
};

var GridRowContext = {
  ctx: ctx,
  make: make,
  Provider: Provider
};

var init = "flex";

function make$1(className, wrap, justify, align) {
  var classes = [init];
  classes.push(wrap ? "flex-wrap" : "flex-nowrap");
  classes.push(justify === "space-between" ? "justify-space-between" : (
          justify === "end" ? "justify-end" : (
              justify === "start" ? "justify-start" : (
                  justify === "center" ? "justify-center" : "justify-space-around"
                )
            )
        ));
  classes.push(align === "start" ? "items-start" : (
          align === "center" ? "items-center" : "items-end"
        ));
  var match = Twind.tw(Twind.apply(classes));
  if (className !== undefined) {
    return [
              match,
              className
            ].join(" ");
  } else {
    return match;
  }
}

var GridRowTwind = {
  init: init,
  make: make$1
};

function MxRC__Grid__Row(Props) {
  var className = Props.className;
  var style = Props.style;
  var wrapOpt = Props.wrap;
  var justifyOpt = Props.justify;
  var alignOpt = Props.align;
  var space = Props.space;
  var dynamicSpace = Props.dynamicSpace;
  var children = Props.children;
  var wrap = wrapOpt !== undefined ? wrapOpt : true;
  var justify = justifyOpt !== undefined ? justifyOpt : "start";
  var align = alignOpt !== undefined ? alignOpt : "start";
  var spaceRef = React.useRef(space);
  var dynamicSpaceRef = React.useRef(dynamicSpace);
  var match = React.useState(function () {
        return MxLibs__BreakpointSub.breakpoints;
      });
  var setScreens = match[1];
  var screens = match[0];
  React.useLayoutEffect((function () {
          var token = MxLibs__BreakpointSub.subscribe(function (screens) {
                return Belt_Option.forEach(dynamicSpaceRef.current, (function (param) {
                              return Curry._1(setScreens, (function (param) {
                                            return screens;
                                          }));
                            }));
              });
          return (function (param) {
                    return MxLibs__BreakpointSub.unsubscribe(token);
                  });
        }), []);
  var match$1 = spaceRef.current;
  var match$2 = dynamicSpaceRef.current;
  var space$1;
  if (match$1 !== undefined) {
    if (match$2 !== undefined) {
      console.warn("`space` or `dynamic space` only can be set one");
      space$1 = match$1;
    } else {
      space$1 = match$1;
    }
  } else if (match$2 !== undefined) {
    var mx = Belt_Option.map(Belt_Map.findFirstBy(Belt_Map.fromArray(match$2[0], MxLibs__BreakpointSub.BreakpointPubSub.BreakpointCmp), (function (k, param) {
                return screens.includes(k);
              })), (function (param) {
            return param[1];
          }));
    var my = Belt_Option.map(Belt_Map.findFirstBy(Belt_Map.fromArray(match$2[1], MxLibs__BreakpointSub.BreakpointPubSub.BreakpointCmp), (function (k, param) {
                return screens.includes(k);
              })), (function (param) {
            return param[1];
          }));
    space$1 = [
      Belt_Option.getWithDefault(mx, 0),
      Belt_Option.getWithDefault(my, 0)
    ];
  } else {
    space$1 = [
      0,
      0
    ];
  }
  var spacey = space$1[1];
  var spacex = space$1[0];
  var style$1 = spacey !== 0 ? Caml_option.some(Object.assign({}, Belt_Option.getWithDefault(style, {}), {
              gridRowGap: spacey.toString() + "px"
            })) : style;
  var value = React.useMemo((function () {
          return {
                  spacex: spacex
                };
        }), [spacex]);
  var className$1 = make$1(className, wrap, justify, align);
  var children$1 = Belt_Option.getWithDefault(children, null);
  var tmp = {
    className: className$1
  };
  if (style$1 !== undefined) {
    tmp.style = Caml_option.valFromOption(style$1);
  }
  return React.createElement(MxRC__Grid__Row$GridRowContext$Provider, {
              value: value,
              children: React.createElement("div", tmp, children$1)
            });
}

var make$2 = MxRC__Grid__Row;

export {
  GridRowContext ,
  GridRowTwind ,
  make$2 as make,
  
}
/* ctx Not a pure module */
