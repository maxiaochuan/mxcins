// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Curry from "rescript/lib/es6/curry.js";
import * as React from "react";
import * as MxHooks from "@mxcins/hooks/src/MxHooks.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as MxLibs__Raf from "@mxcins/webapi/src/raf/MxLibs__Raf.js";

function getDomRect(node) {
  var rect = node.getBoundingClientRect();
  return {
          top: rect.top | 0,
          bottom: rect.bottom | 0,
          width: rect.width | 0,
          height: rect.height | 0
        };
}

function getWinRect(param) {
  return {
          top: 0,
          bottom: window.innerHeight,
          width: window.innerWidth,
          height: window.innerHeight
        };
}

function getFixed(target, container, offset) {
  if (offset.TAG === /* OffsetTop */0) {
    var top = offset._0;
    if (top !== undefined && target.top > (container.top - top | 0)) {
      return top + target.top | 0;
    } else {
      return ;
    }
  }
  var bottom = offset._0;
  if (bottom === undefined) {
    return ;
  }
  if (target.bottom >= (container.bottom + bottom | 0)) {
    return ;
  }
  var offset$1 = window.innerHeight - target.bottom | 0;
  return bottom + offset$1 | 0;
}

var AffixUtils = {
  getDomRect: getDomRect,
  getWinRect: getWinRect,
  getFixed: getFixed
};

var events = [
  "resize",
  "scroll",
  "touchstart",
  "touchmove",
  "touchend",
  "pageshow",
  "load"
];

function MxRC__Affix(Props) {
  var offsetTopOpt = Props.offsetTop;
  var offsetBottom = Props.offsetBottom;
  var tar = Props.target;
  var children = Props.children;
  var offsetTop = offsetTopOpt !== undefined ? offsetTopOpt : 0;
  var containerRef = React.useRef(null);
  var fixedRef = React.useRef(null);
  var targetRef = React.useRef(undefined);
  var match = MxHooks.useGetState(function (param) {
        return /* Unfixed */0;
      });
  var setState = match[1];
  var state = match[0];
  var updateRef = React.useRef(function (param) {
        
      });
  var targetType;
  if (tar !== undefined) {
    var target = Curry._1(tar, undefined);
    if (target == null) {
      targetType = /* Null */2;
    } else {
      targetRef.current = Caml_option.some(target);
      targetType = /* Element */1;
    }
  } else {
    targetType = /* Default */0;
  }
  React.useEffect((function () {
          updateRef.current = MxLibs__Raf.throttle(undefined, (function (param) {
                  var container = containerRef.current;
                  if (container == null) {
                    return ;
                  }
                  var match = targetRef.current;
                  var targetRect;
                  switch (targetType) {
                    case /* Default */0 :
                        targetRect = getWinRect(undefined);
                        break;
                    case /* Element */1 :
                        targetRect = match !== undefined ? getDomRect(Caml_option.valFromOption(match)) : undefined;
                        break;
                    case /* Null */2 :
                        targetRect = undefined;
                        break;
                    
                  }
                  if (targetRect === undefined) {
                    return ;
                  }
                  var containerRect = getDomRect(container);
                  var fixedTop = getFixed(targetRect, containerRect, {
                        TAG: /* OffsetTop */0,
                        _0: offsetTop
                      });
                  var fixedBottom = getFixed(targetRect, containerRect, {
                        TAG: /* OffsetBottom */1,
                        _0: offsetBottom
                      });
                  var next;
                  var exit = 0;
                  if (fixedTop !== undefined || fixedBottom !== undefined) {
                    exit = 1;
                  } else {
                    next = /* Unfixed */0;
                  }
                  if (exit === 1) {
                    next = /* Fixed */{
                      fixed: {
                        position: "fixed",
                        top: fixedTop !== undefined ? String(fixedTop) + "px" : "initial",
                        bottom: fixedTop !== undefined || fixedBottom === undefined ? "initial" : String(fixedBottom) + "px",
                        width: String(containerRect.width) + "px",
                        height: String(containerRect.height) + "px",
                        zIndex: "10"
                      },
                      placeholder: {
                        width: String(containerRect.width) + "px",
                        height: String(containerRect.height) + "px"
                      }
                    };
                  }
                  return Curry._1(setState, (function (prev) {
                                if (prev) {
                                  if (next) {
                                    return prev;
                                  } else {
                                    return next;
                                  }
                                } else if (next) {
                                  return next;
                                } else {
                                  return /* Unfixed */0;
                                }
                              }));
                }));
          Curry._1(updateRef.current, undefined);
          
        }), [
        targetType,
        targetRef.current,
        offsetTop,
        offsetBottom
      ]);
  React.useEffect((function () {
          var handler = MxLibs__Raf.throttle(undefined, (function (param) {
                  return Curry._1(updateRef.current, undefined);
                }));
          var match = targetRef.current;
          var node;
          switch (targetType) {
            case /* Default */0 :
                node = Caml_option.some(window);
                break;
            case /* Element */1 :
                node = match !== undefined ? Caml_option.some(Caml_option.valFromOption(match)) : undefined;
                break;
            case /* Null */2 :
                node = undefined;
                break;
            
          }
          var bind = function (param) {
            if (node === undefined) {
              return ;
            }
            var node$1 = Caml_option.valFromOption(node);
            events.forEach(function (name) {
                  node$1.addEventListener(name, handler);
                  
                });
            
          };
          var unbind = function (param) {
            if (node === undefined) {
              return ;
            }
            var node$1 = Caml_option.valFromOption(node);
            events.forEach(function (name) {
                  node$1.removeEventListener(name, handler);
                  
                });
            
          };
          bind(undefined);
          return unbind;
        }), [
        targetType,
        targetRef.current
      ]);
  var placeholder = state ? React.createElement("div", {
          style: {
            height: state.placeholder.height,
            width: state.placeholder.width
          }
        }) : null;
  var child = children !== undefined ? Caml_option.valFromOption(children) : null;
  return React.createElement("div", {
              ref: containerRef
            }, placeholder, React.createElement("div", {
                  ref: fixedRef,
                  style: state ? ({
                        bottom: state.fixed.bottom,
                        height: state.fixed.height,
                        position: state.fixed.position,
                        top: state.fixed.top,
                        width: state.fixed.width,
                        zIndex: state.fixed.zIndex
                      }) : ({})
                }, child));
}

var make = MxRC__Affix;

export {
  AffixUtils ,
  events ,
  make ,
  
}
/* react Not a pure module */
